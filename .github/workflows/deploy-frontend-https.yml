name: Deploy Frontend HTTPS

on:
  push:
    branches: [ main ]
    paths:
      - 'frontend/**'
      - 'infrastructure/kubernetes/frontend/**'
      - 'infrastructure/kubernetes/ingress/fiapx-ingress.yaml'
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deploy even without changes'
        required: false
        default: false
        type: boolean
      image_tag:
        description: 'Custom image tag (default: v2.4-https)'
        required: false
        default: 'v2.4-https'
        type: string
      node_ips:
        description: 'Kubernetes node IPs (comma separated)'
        required: false
        default: '18.118.109.214,54.210.189.246'
        type: string

env:
  DOCKER_REGISTRY: hmoraes
  IMAGE_NAME: fiapx-frontend
  NAMESPACE: fiapx
  DOMAIN: fiapx.wecando.click

jobs:
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      frontend: ${{ steps.filter.outputs.frontend }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check for changes
        uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            frontend:
              - 'frontend/**'
              - 'infrastructure/kubernetes/frontend/**'
              - 'infrastructure/kubernetes/ingress/fiapx-ingress.yaml'

  build:
    name: Build Frontend HTTPS
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.frontend == 'true' || github.event.inputs.force_deploy == 'true'
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ github.event.inputs.image_tag || 'v2.4-https' }}
            type=raw,value=latest-https
            type=sha,prefix=https-

      - name: Verify HTTPS configuration
        run: |
          echo "🔍 Verificando configuração HTTPS..."
          if [ -f "frontend/config-https.js" ]; then
            echo "✅ config-https.js encontrado"
            echo "📋 URLs configuradas:"
            grep -E "(AUTH_SERVICE_URL|UPLOAD_SERVICE_URL|PROCESSING_SERVICE_URL|STORAGE_SERVICE_URL)" frontend/config-https.js || true
          else
            echo "❌ config-https.js não encontrado!"
            exit 1
          fi

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Verify image
        run: |
          echo "✅ Imagem criada com sucesso!"
          echo "📦 Tags: ${{ steps.meta.outputs.tags }}"

  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: [build]
    if: success()
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Prepare node IPs
        id: nodes
        run: |
          IPS="${{ github.event.inputs.node_ips || '18.118.109.214,54.210.189.246' }}"
          echo "node_ips=$IPS" >> $GITHUB_OUTPUT
          echo "📋 Node IPs configurados: $IPS"

      - name: Test connectivity and deploy
        run: |
          IFS=',' read -ra NODES <<< "${{ steps.nodes.outputs.node_ips }}"
          SUCCESSFUL_NODE=""
          
          for NODE_IP in "${NODES[@]}"; do
            echo "🔍 Testando conectividade com $NODE_IP..."
            
            # Adicionar à known_hosts
            ssh-keyscan -H $NODE_IP >> ~/.ssh/known_hosts 2>/dev/null || true
            
            # Testar conectividade SSH
            if ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no ${{ secrets.SSH_USER }}@$NODE_IP "echo 'SSH conectado com sucesso'" 2>/dev/null; then
              echo "✅ Conectado com sucesso ao node $NODE_IP"
              SUCCESSFUL_NODE=$NODE_IP
              break
            else
              echo "❌ Falha na conexão com $NODE_IP"
            fi
          done
          
          if [ -z "$SUCCESSFUL_NODE" ]; then
            echo "❌ Não foi possível conectar a nenhum node!"
            exit 1
          fi
          
          echo "🚀 Usando node $SUCCESSFUL_NODE para deploy..."
          
          # Atualizar imagem no deployment
          IMAGE_TAG="${{ github.event.inputs.image_tag || 'v2.4-https' }}"
          sed -i "s|image: hmoraes/fiapx-frontend:.*|image: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:$IMAGE_TAG|g" infrastructure/kubernetes/frontend/frontend.yaml
          
          # Enviar arquivos para o cluster
          scp infrastructure/kubernetes/frontend/frontend.yaml ${{ secrets.SSH_USER }}@$SUCCESSFUL_NODE:/tmp/
          scp infrastructure/kubernetes/ingress/fiapx-ingress.yaml ${{ secrets.SSH_USER }}@$SUCCESSFUL_NODE:/tmp/
          
          # Executar deploy
          ssh ${{ secrets.SSH_USER }}@$SUCCESSFUL_NODE "
            set -e
            echo '🔄 Criando namespace se necessário...'
            kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
            
            echo '🔄 Aplicando configurações do frontend...'
            kubectl apply -f /tmp/frontend.yaml
            
            echo '🔄 Aplicando configurações do Ingress...'
            kubectl apply -f /tmp/fiapx-ingress.yaml
            
            echo '🔄 Forçando atualização do deployment...'
            kubectl rollout restart deployment/frontend-deployment -n ${{ env.NAMESPACE }}
            
            echo '⏳ Aguardando rollout do frontend...'
            kubectl rollout status deployment/frontend-deployment -n ${{ env.NAMESPACE }} --timeout=300s
            
            echo '📋 Status dos pods:'
            kubectl get pods -n ${{ env.NAMESPACE }} -l app=frontend
            
            echo '📋 Status do ingress:'
            kubectl get ingress fiapx-ingress -n ${{ env.NAMESPACE }} -o wide
            
            echo '🧹 Limpando arquivos temporários...'
            rm -f /tmp/frontend.yaml /tmp/fiapx-ingress.yaml
          "

  verify:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: [deploy]
    if: success()
    
    steps:
      - name: Wait for deployment stabilization
        run: |
          echo "⏳ Aguardando estabilização do deployment..."
          sleep 60

      - name: Test HTTPS endpoint
        run: |
          echo "🔍 Testando endpoint HTTPS..."
          
          # Testar conectividade HTTPS
          for i in {1..5}; do
            echo "Tentativa $i/5..."
            
            if curl -s -k --connect-timeout 15 --max-time 30 https://${{ env.DOMAIN }} >/dev/null; then
              echo "✅ HTTPS respondendo com sucesso!"
              
              # Verificar se contém conteúdo esperado
              if curl -s -k --connect-timeout 15 https://${{ env.DOMAIN }} | grep -q "FIAP X"; then
                echo "✅ Conteúdo do frontend carregado corretamente!"
              else
                echo "⚠️  Frontend carregado mas conteúdo pode estar incorreto"
              fi
              break
            else
              echo "❌ Tentativa $i falhou, aguardando..."
              if [ $i -lt 5 ]; then
                sleep 30
              fi
            fi
          done

      - name: Test SSL certificate
        run: |
          echo "🔐 Verificando certificado SSL..."
          
          # Verificar certificado
          if echo | timeout 30 openssl s_client -servername ${{ env.DOMAIN }} -connect ${{ env.DOMAIN }}:443 2>/dev/null | grep -q "Verify return code: 0"; then
            echo "✅ Certificado SSL válido"
          else
            echo "⚠️  Certificado SSL ainda sendo emitido ou inválido"
          fi

      - name: Test API endpoints
        run: |
          echo "🔍 Testando endpoints das APIs..."
          
          BASE_URL="https://${{ env.DOMAIN }}/api"
          
          # Testar cada endpoint da API
          for endpoint in "auth/health" "upload/health" "processing/health" "storage/health"; do
            echo "Testando $BASE_URL/$endpoint..."
            
            if curl -s -k --connect-timeout 10 --max-time 20 "$BASE_URL/$endpoint" >/dev/null; then
              echo "✅ $endpoint respondendo"
            else
              echo "⚠️  $endpoint não respondendo (pode ser normal se health check não implementado)"
            fi
          done

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [deploy, verify]
    if: always()
    
    steps:
      - name: Notify success
        if: needs.deploy.result == 'success' && needs.verify.result == 'success'
        run: |
          echo "🎉 Frontend HTTPS deployado com sucesso!"
          echo ""
          echo "✅ Deploy Status: Sucesso"
          echo "🌐 URL: https://${{ env.DOMAIN }}"
          echo "📦 Imagem: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.event.inputs.image_tag || 'v2.4-https' }}"
          echo "🔧 Namespace: ${{ env.NAMESPACE }}"
          echo "📅 Commit: ${{ github.sha }}"
          echo "👤 Triggered by: ${{ github.actor }}"
          echo ""
          echo "🌐 URLs de Acesso:"
          echo "- Frontend: https://${{ env.DOMAIN }}"
          echo "- API Auth: https://${{ env.DOMAIN }}/api/auth"
          echo "- API Upload: https://${{ env.DOMAIN }}/api/upload"
          echo "- API Processing: https://${{ env.DOMAIN }}/api/processing"
          echo "- API Storage: https://${{ env.DOMAIN }}/api/storage"

      - name: Notify partial success
        if: needs.deploy.result == 'success' && needs.verify.result != 'success'
        run: |
          echo "⚠️  Frontend deployado mas verificação falhou!"
          echo ""
          echo "✅ Deploy Status: Sucesso"
          echo "❌ Verify Status: Falhou"
          echo "🌐 URL: https://${{ env.DOMAIN }}"
          echo "💡 Verifique manualmente se o site está funcionando"

      - name: Notify failure
        if: needs.deploy.result == 'failure'
        run: |
          echo "❌ Deploy do Frontend HTTPS falhou!"
          echo ""
          echo "❌ Deploy Status: Falhou"
          echo "🌐 URL: https://${{ env.DOMAIN }}"
          echo "📦 Imagem: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.event.inputs.image_tag || 'v2.4-https' }}"
          echo "📅 Commit: ${{ github.sha }}"
          echo "📋 Logs: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          script: |
            const deployStatus = '${{ needs.deploy.result }}';
            const verifyStatus = '${{ needs.verify.result }}';
            
            let emoji = '❌';
            let message = 'deployment failed';
            
            if (deployStatus === 'success' && verifyStatus === 'success') {
              emoji = '🎉';
              message = 'deployed successfully with HTTPS';
            } else if (deployStatus === 'success') {
              emoji = '⚠️';
              message = 'deployed but verification failed';
            }
            
            const comment = `${emoji} Frontend HTTPS ${message}!

            🌐 **URL**: https://${{ env.DOMAIN }}
            📦 **Image**: \`${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.event.inputs.image_tag || 'v2.4-https' }}\`
            📅 **Commit**: \`${{ github.sha }}\`
            
            ${deployStatus === 'success' && verifyStatus === 'success' ? '✅ Frontend acessível via HTTPS com certificado SSL válido!' : ''}
            ${deployStatus === 'success' && verifyStatus !== 'success' ? '⚠️ Verifique manualmente se o site está funcionando corretamente.' : ''}`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
